#!/usr/bin/python3
import os, pwd, sys, stat, platform
import argparse
import configparser
from time import sleep
from shutil import copyfile
from subprocess import call, check_output

#
# COMMAND: Start a container.
#
def START(arguments, container_name):
  c = get_container_vars(container_name)
  initialize(c)

  # Assure all bind mounts are mounted.
  for src,dst in c['mounts'].items():
    dst = '%s/%s' % (c['root'], dst)
    mount(src, dst.replace('//', '/'))

  # Start the container.
  call(['lxc-start', "-F", "-n%s" % c['name'], '/sbin/init'])

  # Sleep a little and umount all mounts.
  sleep(2)
  for src,dst in c['mounts'].items():
    dst = '%s/%s' % (c['root'], dst)
    umount(src, dst.replace('//', '/'))

#
# COMMAND: Stop a container.
#
def STOP(arguments, container_name):
  c = get_container_vars(container_name)
  if not os.path.exists(c['root']):
    quit('container does not exist!')

  # First gently stop the container, then umount the filesystems.
  call(['lxc-stop', "-n%s" % c['name']])
  for src,dst in c['mounts'].items():
    dst = '%s/%s' % (c['root'], dst)
    umount(src, dst.replace('//', '/'))

#
# COMMAND: Destroy a container.
#
def DESTROY(arguments, container_name):
  c = get_container_vars(container_name)
  if not os.path.exists(c['root']):
    quit('container does not exist!')

  # Umount everything FIRST, as it has already wiped out a home directory!
  for src,dst in c['mounts'].items():
    dst = '%s/%s' % (c['root'], dst)

    # Luckily, after ^^^, the umount function stops the script if umounts fail!
    umount(src, dst.replace('//', '/'))

  call(['lxc-destroy', "-n%s" % c['name']])

#
# COMMAND: Update the /etc/hosts file.
#
def UPDHOSTS(arguments, container_name):
  v = get_vars()

  # Generate the list of domain names for each directory under www/.
  DOMAINS = []
  for d in os.listdir("%s/www" % v['scriptdir']):
    if d != '.git':
      if d != 'default':
        if os.path.isdir("%s/%s" % ("%s/www" % v['scriptdir'], d)):
          DOMAINS.append("%s.loc" % d)
  DOMAINS = sorted(DOMAINS)

  # Generate the lines we'd like to inject.
  MARKER_START = "# update-etc-hosts - DO NOT TOUCH THIS SECTION! #############\n"
  MARKER_END   = "# /update-etc-hosts #########################################\n"
  LINES = [MARKER_START]
  linebuf = [v['ipv4_address']]
  for domain in DOMAINS:
    linebuf.append(domain)
    if len(linebuf) == 4:
      LINES.append(" ".join(linebuf) + "\n")
      linebuf = [v['ipv4_address']]
  if len(linebuf) > 1:
    LINES.append(" ".join(linebuf) + "\n")
  LINES.append(MARKER_END)

  # Read /etc/hosts and replace OR add the new lines, generate a full new buffer.
  buffer = []
  with open('/etc/hosts', 'r') as hro:
    had_old_section = False
    within_old_section = False
    for line in hro.readlines():
      if line == MARKER_START:
        within_old_section = had_old_section = True
      if within_old_section:
        if line == MARKER_END:
          within_old_section = False

          # Now append the newly generated section just in place.
          for line in LINES:
            buffer.append(line)
        continue
      else:
        buffer.append(line)
    if not had_old_section:
      last_line = buffer.pop()
      buffer.append(last_line)
      if last_line != "\n":
        buffer.append("\n")
      for line in LINES:
        buffer.append(line)
  hro.close()

  # Reopen /etc/hosts in truncated write mode, and rewrite the file.
  with open('/etc/hosts', 'w') as hw:
    for line in buffer:
      hw.write(line)
  hw.close()
  
  if had_old_section:
    print("Successfully replaced the old hosts in /etc/hosts!\n")
  else:
    print("Successfully added the hosts to /etc/hosts!\n")
  print("".join(LINES))

#
# Retrieve a list of all containers.
#
def containers(check = False):
  global _containers
  if not '_containers' in globals():
    _containers = {}
    for d in os.listdir(get_var('scriptdir')):
      if d != '.git':
        if os.path.isdir(d) and not os.path.islink(d):
          if d not in _containers:
            if 'config.ini' in os.listdir("%s/%s" % (get_var('scriptdir'), d)):
              _containers[d] = []
        if os.path.islink(d):
          dst = os.path.basename(os.path.realpath(d))
          if dst not in _containers:
            _containers[dst] = []
          _containers[dst].append(d)
  if check:
    for container,aliases in _containers.items():
      if (check in aliases) or (check == container):
        return container
    return False
  return _containers

#
# Initialize a container when it does not yet exist.
#
def initialize(c):

  # When the container doesn't exist yet, we need to create it.
  if not os.path.exists(c['root']):
    call(["lxc-create",
          "-t%s" % c['template'],
          "-n%s" % c['name']])

    # Configure the static IP address and silence app armor (since Ubuntu 14.10)
    with open("%s/config" % c['lxcdir'], "a") as config:
      config.write("\n# CUSTOM CONFIGURATION FOR %s\n" % c['name'])
      config.write("lxc.network.ipv4 = %s/16\n" % c['ipv4_address'])
      config.write("lxc.aa_allow_incomplete = 1")

    # Statically configure the (Debian) container since lxc.network.ipv4 doesn't
    # work reliably anymore since Ubuntu 14.10, this does ;).
    if os.path.exists("%s/etc/network/interfaces" % c['root']):
      with open("%s/etc/network/interfaces" % c['root'], "w") as interfaces:
        interfaces.write("auto lo\n")
        interfaces.write("iface lo inet loopback\n\n")
        interfaces.write("auto eth0\n")
        interfaces.write("iface eth0 inet static\n")
        interfaces.write("        address %s\n" % c['ipv4_address'])
        interfaces.write("        netmask 255.255.255.0\n")
        interfaces.write("        gateway %s\n" % c['ipv4_address_host'])
        interfaces.write("        dns-nameservers %s\n" % c['ipv4_address_host'])
    if os.path.exists("%s/etc/resolv.conf" % c['root']):
      with open("%s/etc/resolv.conf" % c['root'], "w") as resolvconf:
        resolvconf.write("nameserver %s\n" % c['ipv4_address_host'])

    # Install the provisioner scripts.
    for script in c['scripts']:
      service = os.path.basename(script).replace('.sh', '')
      copyfile(script, '%s/etc/init.d/%s' % (c['root'], service))
      call(['chmod', '755', '%s/etc/init.d/%s' % (c['root'], service)])
      call(['chroot', c['root'], '/usr/sbin/update-rc.d', service, 'defaults'])

    # Add a explanatory message to /etc/issue.
    if os.path.exists("%s/etc/issue" % c['root']):
      with open("%s/etc/issue" % c['root'], "a") as etcissue:
        etcissue.write("Welcome to your LXC container %s!\n\n" % c['name'])
        etcissue.write("This is not a vm, but a isolated container keeping\n")
        etcissue.write("your development tools isolated. Login with root/root\n")
        etcissue.write("and shut it down with 'halt -p'.\n\n")

    # Create two provisioner helper scripts (sh, php) with all variables.
    with open("%s/etc/lxc-containervars.sh" % c['root'], 'w+') as varssh:
      varssh.write("#!/bin/bash\n")
      for k, v in sorted(c.items()):
        if type(v) == str:
          varssh.write("export LXC_%s=\"%s\"\n" % (k.upper(), v))
    with open("%s/etc/lxc-containervars.php" % c['root'], 'w+') as varsphp:
      varsphp.write("<?PHP\n")
      for k, v in sorted(c.items()):
        if type(v) == str:
          varsphp.write("$lxc_%s = \"%s\";\n" % (k, v))

    # Start the instance for the first time, the provisioner will run and shut
    # itself down at the very end of the process. A proper mount follows.
    call(["lxc-start", "-F", "-n%s" % c['name'], '/sbin/init'])

#
# Mount the given src,dst bind mount instruction.
#
def mount(src, dst):
  if not ismount(dst):
    if not os.path.exists(dst):
      call(['mkdir', '-p', dst])
    call(['mount', '--bind', src, dst])
    sleep(1)
  if not ismount(dst):
    quit("apparently %s didn't bind mount!" % dst)

#
# Check whether the given path is mounted or whether it isn't.
#
def ismount(path):
  if path in str(check_output(['mount'])):
    return True
  return False

#
# Umount the given src,dst bind mount instruction.
#
def umount(src, dst):
  if ismount(dst):
    call(['umount', '--force', dst])
    sleep(1)
  if ismount(dst):
    quit("%s DID NOT cleanly umount, check lsof!" % dst)

#
# Satisfy that all dependencies are met and won't cause issues.
#
def test_environment_dependencies(prog=None):

  # Check for the given binaries existence.
  if prog is not None:
    for dir in os.environ['PATH'].split(os.pathsep):
      if os.path.exists(os.path.join(dir, prog)):
        return True
    return False

  # Perform all runtime tests.
  v = get_vars()
  deps = ['chroot', 'chmod', 'mount', 'umount',
          'lxc-start', 'lxc-stop', 'lxc-destroy']
  if pwd.getpwuid(os.stat(v['scriptdir']).st_uid).pw_dir not in v['scriptdir']:
    quit("containers repository should be put within your home directory!")
  if platform.system() != 'Linux':
    quit('This only works on Linux.')
  if oct(stat.S_IMODE(os.lstat(v['lxcroot']).st_mode)) != '0o705':
    quit('Please do "sudo chmod 705 %s".' % v['lxcroot'])
  for dep in deps:
    if not test_environment_dependencies(dep):
      quit("dependency %s not satisfied!" % dep)

#
# Get the container variables.
#
def get_container_vars(container_name):
  c = get_vars()
  c['name'] = container_name
  c['dir'] = '%s/%s' % (c['scriptdir'], container_name)
  c['lxcdir'] = "%s/%s" % (c['lxcroot'], container_name)
  c['root'] = "%s/rootfs" % c['lxcdir']

  # Collect every script ending on .sh as script.
  c['scripts'] = []
  for f in os.listdir(c['dir']):
    if f[-3:] == '.sh':
      c['scripts'].append("%s/%s" % (c['dir'], f))

  # Parse the container specific config.ini, which can override a few bits.
  cnf = configparser.ConfigParser()
  cnf.read("%s/config.ini" % c['dir'])
  if 'container' in cnf:
    if 'template' in cnf['container']:
      c['template'] = cnf['container']['template'].strip()
  if 'network' in cnf:
    if 'ipv4_address' in cnf['network']:
      c['ipv4_address'] = cnf['network']['ipv4_address'].strip()
    if 'ipv4_address_host' in cnf['network']:
      c['ipv4_address_host'] = cnf['network']['ipv4_address_host'].strip()
  if 'bindmounts' in cnf:
    for src in cnf['bindmounts']:
      dst = cnf.get('bindmounts', src)
      for k, v in c.items():
        if type(v) == str:
          dst = dst.replace('$%s' % k, v)
          src = src.replace('$%s' % k, v)
      c['mounts'][src] = dst
  return c

#
# Retrieve the argument parser object and the parsed arguments.
#
def get_parser_and_arguments():
  descr = 'A minimalist LXC based container manager'
  if ('-h' in sys.argv) or ('--help' in sys.argv):
    sys.argv = [sys.argv[0], 'fake']
  if ('-u' in sys.argv) or ('--update-hosts' in sys.argv):
    sys.argv = [sys.argv[0], '-u', 'fake', 'start']
  else:
    if (len(sys.argv)) == 1:
      sys.argv.append('fake')
    if (len(sys.argv)) == 2:
      sys.argv.append('start')
  _containers = []
  for c,aliases in containers().items():
    if len(aliases):
      _containers.append("%s (%s)" % (c, ", ".join(aliases)))
    else:
      _containers.append(c)
  descr_c = "\n".join(["  - %s" % c for c in _containers])
  descr = '%s\n\ncontainers:\n%s' % (descr, descr_c)
  parser = argparse.ArgumentParser(
                formatter_class=argparse.RawTextHelpFormatter,
                add_help=False,
                prog='./server',
                description=descr)
  parser.add_argument('--update-hosts', '-u',
                dest='updhosts', action='store_true', default=False,
                help='Update the /etc/hosts file.')
  parser.add_argument('container',
                help='The name of the container')
  parser.add_argument('command',
                choices=['start', 'stop', 'destroy'],
                help='Whether to start (default), stop or destroy the container.')
  arguments = parser.parse_args()
  if arguments.updhosts:
    arguments.command = 'updhosts'
  return (parser, arguments)

#
# Get the master configuration.
#
def get_vars():
  v = {}
  v['mounts'] = {}
  v['lxcroot'] = '/var/lib/lxc'
  v['scriptdir'] = os.path.dirname(os.path.abspath(__file__))
  v['home'] = pwd.getpwuid(os.stat(v['scriptdir']).st_uid).pw_dir
  v['user'] = pwd.getpwuid(os.stat(v['scriptdir']).st_uid).pw_name

  if not os.path.exists("%s/config.ini" % v['scriptdir']):
    quit("cannot find %s!" % ("%s/config.ini" % v['scriptdir']))
  mastercnf = configparser.ConfigParser()
  mastercnf.read("%s/config.ini" % v['scriptdir'])
  v['template'] = mastercnf['container']['template'].strip()
  v['ipv4_address'] = mastercnf['network']['ipv4_address'].strip()
  v['ipv4_address_host'] = mastercnf['network']['ipv4_address_host'].strip()
  if 'bindmounts' in mastercnf:
    for src in mastercnf['bindmounts']:
      dst = mastercnf.get('bindmounts', src)
      for key, var in v.items():
        if type(var) == str:
          dst = dst.replace('$%s' % key, var)
          src = src.replace('$%s' % key, var)
      v['mounts'][src] = dst
  return v

#
# Get a variable from the master configuration.
#
def get_var(variable):
  return get_vars()[variable]

#
# Quit the application in case of failure.
#
def quit(msg):
  sys.exit('ERROR: %s' % msg)

#
# Parse and manipulate sys.argv and dispatch code.
#
parser, arguments = get_parser_and_arguments()
if not containers(arguments.container) and not arguments.updhosts:
  parser.print_help()
else:
  # Re-execute ourselves as root from this point on, we'll need to mess
  # around in /var/lib/lxc quite a bit so this makes it much easier.
  if os.geteuid() != 0:
    print("LXC and this script require root-level privileges in order to manage")
    print("your containers and %s, please provide your biggest secret below.\n" % get_var('lxcroot'))
    os.execvp("sudo", ["sudo"] + sys.argv)

  # Test the computing environment for needed binaries, permissions, etc.
  test_environment_dependencies()

  # Dispatch execution to a function with the CAPITALIZED name of the command.
  locals()[arguments.command.upper()](arguments, containers(arguments.container))

#!/usr/bin/python3
import os, pwd, sys, stat, platform
import argparse
import configparser
from time import sleep
from shutil import copyfile
from subprocess import call, check_output

# General purpose, global variables.
SCRIPTDIR = os.path.dirname(os.path.abspath(__file__))
LXCDIR = '/var/lib/lxc'
ERRORF = 'ERROR: %s'

#
# COMMAND: Start a container.
#
def START(arguments, container_name):
  c = get_container(container_name)
  initialize(c)

  # Assure all bind mounts are mounted.
  for src,dst in c['mounts'].items():
    dst = '%s/%s' % (c['root'], dst)
    mount(src, dst.replace('//', '/'))

  # Start the container.
  call(['lxc-start', "-F", "-n%s" % c['name'], '/sbin/init'])

  # Sleep a little and umount all mounts.
  sleep(2)
  for src,dst in c['mounts'].items():
    dst = '%s/%s' % (c['root'], dst)
    umount(src, dst.replace('//', '/'))

#
# COMMAND: Start a container daemonized.
#
def DAEMON(arguments, container_name):
  c = get_container(container_name)
  initialize(c)

  # Assure all bind mounts are mounted.
  for src,dst in c['mounts'].items():
    dst = '%s/%s' % (c['root'], dst)
    mount(src, dst.replace('//', '/'))

  call(['lxc-start', "-d", "-n%s" % c['name'], '/sbin/init'])
  print("Instance started daemonized:")
  print(" - Use './server %s stop' to stop it again." % c['name'])
  print(" - Use 'ssh root@%s' to get into your container.\n" % c['ipv4_address'])

#
# COMMAND: Stop a container.
#
def STOP(arguments, container_name):
  c = get_container(container_name)
  if not os.path.exists(c['root']):
    os.sys.exit(ERRORF % 'container does not exist!')

  # First gently stop the container, then umount the filesystems.
  call(['lxc-stop', "-n%s" % c['name']])
  for src,dst in c['mounts'].items():
    dst = '%s/%s' % (c['root'], dst)
    umount(src, dst.replace('//', '/'))

#
# COMMAND: Destroy a container.
#
def DESTROY(arguments, container_name):
  c = get_container(container_name)
  if not os.path.exists(c['root']):
    os.sys.exit(ERRORF % 'container does not exist!')

  # Umount everything FIRST, as it has already wiped out a home directory!
  for src,dst in c['mounts'].items():
    dst = '%s/%s' % (c['root'], dst)

    # Luckily, after ^^^, the umount function stops the script if umounts fail!
    umount(src, dst.replace('//', '/'))

  call(['lxc-destroy', "-n%s" % c['name']])

#
# Retrieve a list of all containers.
#
def containers(check = False):
  global _containers
  if not '_containers' in globals():
    _containers = {}
    for d in os.listdir(SCRIPTDIR):
      if d != '.git':
        if os.path.isdir(d) and not os.path.islink(d):
          if d not in _containers:
            if 'config.ini' in os.listdir("%s/%s" % (SCRIPTDIR, d)):
              _containers[d] = []
        if os.path.islink(d):
          dst = os.path.basename(os.path.realpath(d))
          if dst not in _containers:
            _containers[dst] = []
          _containers[dst].append(d)
  if check:
    for container,aliases in _containers.items():
      if (check in aliases) or (check == container):
        return container
    return False
  return _containers

#
# Initialize a container when it does not yet exist.
#
def initialize(c):

  # When the container doesn't exist yet, we need to create it.
  if not os.path.exists(c['root']):
    call(["lxc-create",
          "-t%s" % c['template'],
          "-n%s" % c['name']])

    # Configure the static IP address and silence app armor (since Ubuntu 14.10)
    with open("%s/config" % c['lxcdir'], "a") as config:
      config.write("\n# CUSTOM CONFIGURATION FOR %s\n" % c['name'])
      config.write("lxc.network.ipv4 = %s/16\n" % c['ipv4_address'])
      config.write("lxc.aa_allow_incomplete = 1")

    # Install the provisioner scripts.
    for script in c['scripts']:
      service = os.path.basename(script).replace('.sh', '')
      copyfile(script, '%s/etc/init.d/%s' % (c['root'], service))
      call(['chmod', '755', '%s/etc/init.d/%s' % (c['root'], service)])
      call(['chroot', c['root'], '/usr/sbin/update-rc.d', service, 'defaults'])

    # Add a explanatory message to /etc/issue.
    if os.path.exists("%s/etc/issue" % c['root']):
      with open("%s/etc/issue" % c['root'], "a") as etcissue:
        etcissue.write("Welcome to your LXC container %s!\n\n" % c['name'])
        etcissue.write("This is not a vm, but a isolated container keeping\n")
        etcissue.write("your development tools isolated. Login with root/root\n")
        etcissue.write("and shut it down with 'halt -p'.\n\n")

    # Create two provisioner helper scripts (sh, php) with all variables.
    with open("%s/etc/lxc-containervars.sh" % c['root'], 'w+') as varssh:
      varssh.write("#!/bin/bash\n")
      for k, v in sorted(c.items()):
        if type(v) == str:
          varssh.write("export LXC_%s=\"%s\"\n" % (k.upper(), v))
    with open("%s/etc/lxc-containervars.php" % c['root'], 'w+') as varsphp:
      varsphp.write("<?PHP\n")
      for k, v in sorted(c.items()):
        if type(v) == str:
          varsphp.write("$lxc_%s = \"%s\";\n" % (k, v))

    # Start the instance for the first time, the provisioner will run and shut
    # itself down at the very end of the process. A proper mount follows.
    call(["lxc-start", "-F", "-n%s" % c['name'], '/sbin/init'])

#
# Mount the given src,dst bind mount instruction.
#
def mount(src, dst):
  if not ismount(dst):
    if not os.path.exists(dst):
      call(['mkdir', '-p', dst])
    call(['mount', '--bind', src, dst])
    sleep(1)
  if not ismount(dst):
    sys.exit(ERRORF % "apparently %s didn't bind mount!" % dst)

#
# Check whether the given path is mounted or whether it isn't.
#
def ismount(path):
  if path in str(check_output(['mount'])):
    return True
  return False

#
# Umount the given src,dst bind mount instruction.
#
def umount(src, dst):
  if ismount(dst):
    call(['umount', '--force', dst])
    sleep(1)
  if ismount(dst):
    sys.exit(ERRORF % "%s DID NOT cleanly umount, check lsof!" % dst)

#
# Satisfy that all dependencies are met and won't cause issues.
#
def check_dependencies(prog=None):
  if prog is not None:
    for dir in os.environ['PATH'].split(os.pathsep):
      if os.path.exists(os.path.join(dir, prog)):
        return True
    return False
  deps = ['chroot', 'chmod', 'mount', 'umount',
          'lxc-start', 'lxc-stop', 'lxc-destroy']
  if platform.system() != 'Linux':
    sys.exit(ERRORF % 'This only works on Linux.')
  if oct(stat.S_IMODE(os.lstat(LXCDIR).st_mode)) != '0o705':
    sys.exit(ERRORF % 'Please do "sudo chmod 705 %s".' % LXCDIR)
  for dep in deps:
    if not check_dependencies(dep):
      sys.exit(ERRORF % "dependency %s not satisfied!" % dep)

#
# Get the container dictionary.
#
def get_container(container_name):
  c = {}
  c['name'] = container_name
  c['home'] = pwd.getpwuid(os.stat(SCRIPTDIR).st_uid).pw_dir
  c['user'] = pwd.getpwuid(os.stat(SCRIPTDIR).st_uid).pw_name
  c['dir'] = '%s/%s' % (SCRIPTDIR, container_name)
  c['lxcdir'] = "%s/%s" % (LXCDIR, container_name)
  c['scriptdir'] = SCRIPTDIR
  c['root'] = "%s/rootfs" % c['lxcdir']

  # Collect every script ending on .sh as script.
  c['scripts'] = []
  for f in os.listdir(c['dir']):
    if f[-3:] == '.sh':
      c['scripts'].append("%s/%s" % (c['dir'], f))

  # Parse the master config.ini, if keys are missing, this fails badly.
  if not os.path.exists("%s/config.ini" % c['scriptdir']):
    sys.exit(ERRORF % "cannot find %s!" % ("%s/config.ini" % c['scriptdir']))
  mastercnf = configparser.ConfigParser()
  mastercnf.read("%s/config.ini" % c['scriptdir'])
  c['template'] = mastercnf['container']['template'].strip()
  c['ipv4_address'] = mastercnf['network']['ipv4_address'].strip()
  c['ipv4_address_host'] = mastercnf['network']['ipv4_address_host'].strip()

  # Parse the container specific config.ini, which can override a few bits.
  c['mounts'] = {}
  cnf = configparser.ConfigParser()
  cnf.read("%s/config.ini" % c['dir'])
  if 'container' in cnf:
    if 'template' in cnf['container']:
      c['template'] = cnf['container']['template'].strip()
  if 'network' in cnf:
    if 'ipv4_address' in cnf['network']:
      c['ipv4_address'] = cnf['network']['ipv4_address'].strip()
    if 'ipv4_address_host' in cnf['network']:
      c['ipv4_address_host'] = cnf['network']['ipv4_address_host'].strip()
  if 'bindmounts' in cnf:
    for src in cnf['bindmounts']:
      dst = cnf.get('bindmounts', src)
      for k, v in c.items():
        if type(v) == str:
          dst = dst.replace('$%s' % k, v)
          src = src.replace('$%s' % k, v)
      c['mounts'][src] = dst
  return c

#
# Retrieve the argument parser object.
#
def get_parser():
  descr = 'A minimalist LXC based container manager'
  _containers = []
  for c,aliases in containers().items():
    if len(aliases):
      _containers.append("%s (%s)" % (c, ", ".join(aliases)))
    else:
      _containers.append(c)
  descr_c = "\n".join(["  - %s" % c for c in _containers])
  descr = '%s\n\ncontainers:\n%s' % (descr, descr_c)
  parser = argparse.ArgumentParser(
                formatter_class=argparse.RawTextHelpFormatter,
                add_help=False,
                prog='./server',
                description=descr)
  parser.add_argument('container',
                help='The name of the container')
  parser.add_argument('command',
                choices=['start', 'daemon', 'stop', 'destroy'],
                help='Whether to start (default), stop or destroy the container.')
  return parser

#
# Parse argv and dispatch code.
#
try:
  sys.argv[1]
except IndexError:
  sys.argv.append('unset')
try:
  sys.argv[2]
except IndexError:
  sys.argv.append('start')
parser = get_parser()
arguments = parser.parse_args()
if not containers(arguments.container):
  parser.print_help()
else:
  # Re-execute ourselves as root from this point on, we'll need to mess
  # around in /var/lib/lxc quite a bit so this makes it much easier.
  if os.geteuid() != 0:

    print("LXC and this script require root-level privileges in order to manage")
    print("your containers and %s, please provide your biggest secret below.\n" % LXCDIR)
    os.execvp("sudo", ["sudo"] + sys.argv)

  # Check if the user has this script somewhere underneath its home directory,
  # because if it is not, assumptions on mount points will break!
  if pwd.getpwuid(os.stat(SCRIPTDIR).st_uid).pw_dir not in SCRIPTDIR:
    sys.exit(ERRORF % "containers repository should be put within your home directory!")

  # Check for dependencies and call the chosen command by the same-named function.
  check_dependencies()
  locals()[arguments.command.upper()](arguments, containers(arguments.container))
